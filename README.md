An interactive tutorial on specifying and implementing the simply-typed
lambda calculus in Coq using a locally nameless representation.

This tutorial is based on the Stlc tutorial found in the
[metalib](https://github.com/plclub/metalib) repository. However, it
experiments with making two major changes:

1. This version uses the [Equations](https://github.com/mattam82/Coq-Equations)
  Coq package to index the expression type with the number of bound
  variables. This definition means that the local closure predicate is not
  needed --- instead the type "exp 0" only contains locally closed terms.

2. This version uses type classes to simplify the names of operations and
   their lemmas. See the [Classes](src/Classes.v) module for the definition of
   those type classes. Some of the instances are defined in the middle of
   [Definitions](src/Definitions.v) and others at the end of
   [Lemmas](src/Lemmas.v).

INSTALLATION

  The code has been tested with Coq 8.15.0. Other versions of Coq may not
  be compatible. 

  This tutorial depends on the `Metalib.Metatheory` library, available from
  [https://github.com/plclub/metalib](https://github.com/plclub/metalib).
  Make sure that you compile and install this library _first_.

  You also need to install the equations library, version 1.3+8.15 available
  from opam.

  After you have done that, you can use make

    `make`             - Compile all Coq files

CONTENTS

     _CoqProject         - list of modules

     Fin.v               - Finite numbers, defined using equations

     DefinitionsSyntax.v - Specification of STLC using locally nameless
                           representation (LN)

     Lemmas.v            - infrastructure lemmas about binding, similar 
                           to the form generated by LNgen. Proofs differ 
                           due to the use of equations.

     Classes.v           - type class definitions for operations on 
                           syntax (open/close/etc) and their properties
     
     ClassInstances.v    - Use Definitions and Lemmas to instantiate 
                           general type classes.
                         
     ClassRewrites.v     - Rewrite lemmas (equations) for the operations in
                           terms of the class names.
                         
     DefinitionsTyping.v - Typing rules for STLC
                         
     Lec2.v              - type soundness for STLC


WORKING GROUP PLAN (equations)

- Fin.v
  try proof: decrease_fin_inj
  
- DefinitionsSyntax.v
  compare definitions with equations and Fixpoint
  
- Lemmas.v
  pick a proof and try to recreate/simplify it



QUESTIONS (general)

- Should "open" and "subst" call weaken u with every recursion
  under a binder? Or should it be one call where u actually appears.
  (i.e. should u have type exp n or exp 0?)

- Is there a (confluent) rewriting theory for the lemmas?
  Have created a hint db "syntax" for this rewriting theory. But how to use it?

- Is this version any better than the previous version? Not clear.
  * lc predicates are gone, but we now have "weaken" to reason about.
  * The use of dependent types places additional constraints
    (depelim/dependent induction instead of case analysis, 
     inversion, regular induction).
  
  

